/**
 * @skybolt/server-adapter - Skybolt server adapter for Node.js/Bun
 *
 * High-performance asset caching for multi-page applications.
 * Eliminates HTTP requests for cached assets on repeat visits.
 *
 * @module @skybolt/server-adapter
 * @version 3.3.0
 */

import { readFileSync } from 'node:fs'

/**
 * @typedef {Object} Asset
 * @property {string} url - The URL path to the asset
 * @property {string} hash - Content hash for cache invalidation
 * @property {number} size - File size in bytes
 * @property {string} content - Full asset content for inlining
 */

/**
 * @typedef {Object} ClientConfig
 * @property {string} script - Minified client launcher script
 */

/**
 * @typedef {Object} ServiceWorkerConfig
 * @property {string} filename - Service worker filename
 * @property {string} path - URL path for service worker
 */

/**
 * @typedef {Object} RenderMap
 * @property {number} version - Render map schema version
 * @property {string} generated - ISO timestamp of generation
 * @property {string} skyboltVersion - Skybolt version used
 * @property {string} basePath - Base path for assets
 * @property {Record<string, Asset>} assets - Map of source paths to asset data
 * @property {ClientConfig} client - Client script configuration
 * @property {ServiceWorkerConfig} serviceWorker - Service worker configuration
 */

/**
 * @typedef {Object} CookieDict
 * @description A dictionary of cookie names to values
 */

/**
 * Skybolt server adapter for Node.js and Bun.
 *
 * Reads the render map generated by @skybolt/vite-plugin and renders
 * HTML tags for CSS and JavaScript assets. On first visit, assets are
 * inlined; on repeat visits, external links are used (served from SW cache).
 *
 * @example
 * ```javascript
 * import { Skybolt } from '@skybolt/server-adapter'
 *
 * const skybolt = new Skybolt('./dist/.skybolt/render-map.json', req.cookies)
 *
 * const html = `
 *   <head>
 *     ${skybolt.css('src/css/main.css')}
 *     ${skybolt.script('src/js/app.js')}
 *     ${skybolt.launchScript()}
 *   </head>
 * `
 * ```
 */
export class Skybolt {
  /** @type {RenderMap} */
  #map

  /** @type {Map<string, string>} */
  #cachedAssets

  /** @type {string | null} */
  #cdnUrl

  /**
   * Create a new Skybolt instance.
   *
   * @param {string} renderMapPath - Path to the render-map.json file
   * @param {Record<string, string> | null} [cookies=null] - Request cookies object (e.g., req.cookies)
   * @param {string | null} [cdnUrl=null] - Optional CDN base URL to prefix asset URLs
   * @throws {Error} If render map cannot be read or parsed
   */
  constructor(renderMapPath, cookies = null, cdnUrl = null) {
    const content = readFileSync(renderMapPath, 'utf-8')
    this.#map = JSON.parse(content)
    this.#cdnUrl = cdnUrl ? cdnUrl.replace(/\/$/, '') : null
    this.#cachedAssets = this.#parseCookies(cookies)
  }

  /**
   * Render a CSS asset.
   *
   * On first visit (or cache miss), returns an inlined `<style>` tag with
   * `sb-asset` and `sb-url` attributes for the client to cache.
   *
   * On repeat visits (cache hit), returns a `<link>` tag. The Service Worker
   * will serve the asset from cache (~5ms response time).
   *
   * @param {string} entry - Source path of the CSS file (e.g., 'src/css/main.css')
   * @param {Object} [options={}] - Options
   * @param {boolean} [options.async=false] - If true, load CSS asynchronously (non-blocking)
   * @returns {string} HTML string (`<style>` or `<link>` tag)
   *
   * @example
   * ```javascript
   * // Blocking CSS (in <head>)
   * skybolt.css('src/css/main.css')
   *
   * // Non-blocking CSS (above </body>)
   * skybolt.css('src/css/main.css', { async: true })
   * ```
   */
  css(entry, { async = false } = {}) {
    const asset = this.#map.assets[entry]
    if (!asset) {
      return this.#comment(`Skybolt: asset not found: ${entry}`)
    }

    const url = this.#resolveUrl(asset.url)

    if (this.#hasCached(entry, asset.hash)) {
      // Repeat visit - use external link (SW serves from cache)
      if (async) {
        return this.#buildTag('link', {
          rel: 'stylesheet',
          href: url,
          media: 'print',
          onload: "this.media='all'"
        })
      }
      return this.#buildTag('link', { rel: 'stylesheet', href: url })
    }

    // First visit - inline the asset
    if (async) {
      return this.#buildTag('style', {
        'sb-asset': `${entry}:${asset.hash}`,
        'sb-url': url,
        media: 'print',
        onload: "this.media='all'"
      }, asset.content)
    }

    return this.#buildTag('style', {
      'sb-asset': `${entry}:${asset.hash}`,
      'sb-url': url
    }, asset.content)
  }

  /**
   * Render a JavaScript asset.
   *
   * On first visit (or cache miss), returns an inlined `<script>` tag with
   * `sb-asset` and `sb-url` attributes for the client to cache.
   *
   * On repeat visits (cache hit), returns an external `<script>` tag. The
   * Service Worker will serve the asset from cache (~5ms response time).
   *
   * @param {string} entry - Source path of the JS file (e.g., 'src/js/app.js')
   * @param {Object} [options={}] - Options
   * @param {boolean} [options.module=true] - If true, use type="module"; if false, classic script
   * @returns {string} HTML string (`<script>` tag)
   *
   * @example
   * ```javascript
   * // ES module (default)
   * skybolt.script('src/js/app.js')
   *
   * // Classic script
   * skybolt.script('src/js/legacy.js', { module: false })
   * ```
   */
  script(entry, { module = true } = {}) {
    const asset = this.#map.assets[entry]
    if (!asset) {
      return this.#comment(`Skybolt: asset not found: ${entry}`)
    }

    const url = this.#resolveUrl(asset.url)

    /** @type {Record<string, string>} */
    const attrs = {}
    if (module) {
      attrs.type = 'module'
    }

    if (this.#hasCached(entry, asset.hash)) {
      // Repeat visit - use external script (SW serves from cache)
      attrs.src = url
      return this.#buildTag('script', attrs, '')
    }

    // First visit - inline the asset
    attrs['sb-asset'] = `${entry}:${asset.hash}`
    attrs['sb-url'] = url
    return this.#buildTag('script', attrs, asset.content)
  }

  /**
   * Render a preload link for an asset.
   *
   * Preloads are useful for critical resources that should be fetched early.
   * Note: Preloaded resources are NOT cached by the Service Worker.
   *
   * @param {string} entry - Source path of the asset
   * @param {Object} [options={}] - Options
   * @param {string} [options.as] - Resource type (e.g., 'style', 'script', 'font', 'image')
   * @param {string} [options.type] - MIME type (e.g., 'font/woff2')
   * @param {string} [options.crossorigin] - Crossorigin attribute value
   * @param {string} [options.fetchpriority] - Fetch priority ('high', 'low', 'auto')
   * @returns {string} HTML string (`<link rel="preload">` tag)
   *
   * @example
   * ```javascript
   * // Preload a font
   * skybolt.preload('src/fonts/Inter.woff2', {
   *   as: 'font',
   *   type: 'font/woff2',
   *   crossorigin: 'anonymous'
   * })
   * ```
   */
  preload(entry, { as, type, crossorigin, fetchpriority } = {}) {
    const asset = this.#map.assets[entry]
    if (!asset) {
      return this.#comment(`Skybolt: asset not found: ${entry}`)
    }

    const url = this.#resolveUrl(asset.url)

    /** @type {Record<string, string>} */
    const attrs = { rel: 'preload', href: url }

    if (as) attrs.as = as
    if (type) attrs.type = type
    if (crossorigin) attrs.crossorigin = crossorigin
    if (fetchpriority) attrs.fetchpriority = fetchpriority

    return this.#buildTag('link', attrs)
  }

  /**
   * Render the Skybolt client launcher script.
   *
   * This must be included once per page, typically at the end of `<head>` or
   * before `</body>`. It registers the Service Worker and processes any
   * inlined assets on the page.
   *
   * @returns {string} HTML string (meta tag + script tag)
   *
   * @example
   * ```javascript
   * // In your template
   * `<head>
   *   ${skybolt.css('src/css/main.css')}
   *   ${skybolt.launchScript()}
   * </head>`
   * ```
   */
  launchScript() {
    const swPath = this.#map.serviceWorker?.path ?? '/skybolt-sw.js'

    // Config meta tag for client script
    const meta = this.#buildTag('meta', {
      name: 'skybolt-config',
      content: JSON.stringify({ swPath })
    })

    // Client launcher script (must be type="module" - client uses ES module syntax)
    const script = this.#buildTag('script', { type: 'module' }, this.#map.client.script)

    return meta + script
  }

  /**
   * Get the URL for an asset.
   *
   * Useful when you need the asset URL for manual use (e.g., in a srcset
   * or for JavaScript dynamic imports).
   *
   * @param {string} entry - Source path of the asset
   * @returns {string | null} The asset URL, or null if not found
   *
   * @example
   * ```javascript
   * const url = skybolt.getAssetUrl('src/images/hero.webp')
   * // => '/assets/hero-Abc123.webp'
   * ```
   */
  getAssetUrl(entry) {
    const asset = this.#map.assets[entry]
    if (!asset) return null
    return this.#resolveUrl(asset.url)
  }

  /**
   * Get the content hash for an asset.
   *
   * Useful for cache busting or versioning.
   *
   * @param {string} entry - Source path of the asset
   * @returns {string | null} The asset hash, or null if not found
   *
   * @example
   * ```javascript
   * const hash = skybolt.getAssetHash('src/css/main.css')
   * // => 'Pw3rT8vL'
   * ```
   */
  getAssetHash(entry) {
    const asset = this.#map.assets[entry]
    return asset?.hash ?? null
  }

  /**
   * Check if an asset is currently cached by the client.
   *
   * @param {string} entry - Source path of the asset
   * @returns {boolean} True if the asset is cached with the current hash
   *
   * @example
   * ```javascript
   * if (skybolt.isCached('src/css/main.css')) {
   *   // Client has this asset cached
   * }
   * ```
   */
  isCached(entry) {
    const asset = this.#map.assets[entry]
    if (!asset) return false
    return this.#hasCached(entry, asset.hash)
  }

  /**
   * Resolve a URL with optional CDN prefix.
   *
   * @param {string} url - The URL to resolve
   * @returns {string} The resolved URL
   */
  #resolveUrl(url) {
    // Don't prefix absolute URLs
    if (!this.#cdnUrl || url.startsWith('http://') || url.startsWith('https://') || url.startsWith('//')) {
      return url
    }
    return this.#cdnUrl + url
  }

  /**
   * Check if client has a specific asset version cached.
   *
   * @param {string} entry - Asset entry path
   * @param {string} hash - Expected hash
   * @returns {boolean} True if cached with matching hash
   */
  #hasCached(entry, hash) {
    return this.#cachedAssets.get(entry) === hash
  }

  /**
   * Parse the sb_assets cookie(s) into a map.
   *
   * Handles both single cookies and sharded cookies (sb_assets_2, etc.).
   * Format: name:hash,name:hash,...
   *
   * @param {Record<string, string> | null} cookies - Cookies object
   * @returns {Map<string, string>} Map of entry paths to hashes
   */
  #parseCookies(cookies) {
    /** @type {Map<string, string>} */
    const cached = new Map()

    if (!cookies) return cached

    // Check for sharded cookies
    const countStr = cookies['sb_assets_count']
    const count = countStr ? parseInt(countStr, 10) : 0

    let cookieValue = ''

    if (count > 1) {
      // Sharded: combine sb_assets, sb_assets_2, sb_assets_3, ...
      const parts = [cookies['sb_assets'] ?? '']
      for (let i = 2; i <= count; i++) {
        parts.push(cookies[`sb_assets_${i}`] ?? '')
      }
      cookieValue = parts.join('')
    } else {
      cookieValue = cookies['sb_assets'] ?? ''
    }

    if (!cookieValue) return cached

    // URL decode
    try {
      cookieValue = decodeURIComponent(cookieValue)
    } catch {
      // Not encoded, use as-is
    }

    // Parse name:hash pairs
    const pairs = cookieValue.split(',')
    for (const pair of pairs) {
      if (!pair) continue

      // Find rightmost colon (handles Windows paths and entry names with colons)
      const lastColon = pair.lastIndexOf(':')
      if (lastColon === -1) continue

      const name = pair.slice(0, lastColon)
      const hash = pair.slice(lastColon + 1)

      if (name && hash) {
        cached.set(name, hash)
      }
    }

    return cached
  }

  /**
   * Build an HTML tag string.
   *
   * @param {string} tag - Tag name
   * @param {Record<string, string>} attrs - Attributes
   * @param {string} [content] - Inner content (for non-void elements)
   * @returns {string} HTML string
   */
  #buildTag(tag, attrs, content) {
    const attrStr = Object.entries(attrs)
      .map(([key, value]) => ` ${key}="${this.#escapeHtml(value)}"`)
      .join('')

    // Void elements
    if (tag === 'link' || tag === 'meta') {
      return `<${tag}${attrStr}>`
    }

    // Non-void elements (content not escaped - it's trusted CSS/JS)
    return `<${tag}${attrStr}>${content ?? ''}</${tag}>`
  }

  /**
   * Escape HTML special characters.
   *
   * @param {string} str - String to escape
   * @returns {string} Escaped string
   */
  #escapeHtml(str) {
    return str
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#039;')
  }

  /**
   * Generate an HTML comment.
   *
   * @param {string} text - Comment text
   * @returns {string} HTML comment
   */
  #comment(text) {
    // Escape -- in comments to prevent injection
    return `<!-- ${text.replace(/--/g, '\\-\\-')} -->`
  }
}

export default Skybolt
